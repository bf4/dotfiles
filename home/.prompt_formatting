#!/usr/bin/env sh
for file in `brew --prefix`/etc/bash_completion.d/* ; do
  source $file
done
if [ `which brew` ] && [ -f `brew --prefix`/etc/bash_completion ]; then
    . `brew --prefix`/etc/bash_completion
   # source "$(brew --repository)/Library/Contributions/brew_$(echo $0 | cut -d- -f2)_completion.sh"
fi
# handle various places git completion may be
if [ -s `brew --prefix`/etc/bash_completion.d/git-completion.bash ]; then
  echo "using homebrew git completion"
elif [ -f /Applications/Xcode.app/Contents/Developer/usr/share/git-core/git-completion.bash ]; then
  # echo "using apple git completion for /usr/bin/git"
  source /Applications/Xcode.app/Contents/Developer/usr/share/git-core/git-completion.bash
else
  # fall back to local (linked) copy
  echo "using local git completion"
  source $HOME/.git-completion.sh
  # maybe see brew install bash-completion
  # source $(brew --prefix)/etc/bash_completion.d/git-prompt.sh
fi
# brew install grc
[ -s "`brew --prefix grc`/etc/grc.bashrc" ] && source "`brew --prefix grc`/etc/grc.bashrc"
[ -s $HOME/.pythonbrew/etc/bashrc ] && source $HOME/.pythonbrew/etc/bashrc

# Set git autocompletion and PS1 integration for showing git info in terminal
# https://github.com/iambowen/dotfiles/blob/master/bash_profile
# https://gist.github.com/ryknow/3303462/raw/2e2f9dd271f3caa83a435965664e59f0dd4626dc/.bashrc

ps1_set() {
  export PS1="\$(__my_rvm_prompt)\[\e[36m\]$(__my_git_prompt)\[\e[0m\]\w\n📝 $ "
}
__my_rvm_prompt() {
  eval ~/.rvm/bin/rvm-prompt
}
__my_git_prompt() {
  _prompt_colors
  GIT_PS1_SHOWDIRTYSTAT=true
  GIT_PS1_SHOWSTASHSTATE=true
  GIT_PS1_SHOWUNTRACKEDFILES=true
  local git_status="`git status -unormal 2>&1`"
  if ! [[ "$git_status" =~ Not\ a\ git\ repo ]]; then
    if [[ "$git_status" =~ nothing\ to\ commit ]]; then
      # no commits but stuff hasn't been pushed
      if [[ "$git_status" =~ Your\ branch\ is\ ahead ]]; then
        local ansi=$EMR
      else
        local ansi=$C
      fi
    elif [[ "$git_status" =~ nothing\ added\ to\ commit\ but\ untracked\ files\ present ]]; then
      local ansi=$Y:$BGW
    else
      local ansi=$Y
    fi
    if [[ "$git_status" =~ On\ branch\ ([^[:space:]]+) ]]; then
      branch=${BASH_REMATCH[1]}
    else
      branch="(`git describe --all --contains --abbrev=4 HEAD 2> /dev/null || echo HEAD`)"
    fi
    echo -n "$ansi($branch`__git_dirty`)$NONE"
  fi
}
__git_dirty() {
  git diff --quiet head &>/dev/null
  [ $? == 1 ] && echo "!"
}
parse_git_branch() {
  cat .git/HEAD | sed -e 's/^.*refs\/heads\///'
}
_prompt_colors() {
  local NONE="\[\033[0m\]"    # unsets color to term's fg color

  # regular colors
  local K="\[\033[0;30m\]"    # black
  local R="\[\033[0;31m\]"    # red
  local G="\[\033[0;32m\]"    # green
  local Y="\[\033[0;33m\]"    # yellow
  local B="\[\033[0;34m\]"    # blue
  local M="\[\033[0;35m\]"    # magenta
  local C="\[\033[0;36m\]"    # cyan
  local W="\[\033[0;37m\]"    # white

  # emphasized (bolded) colors
  local EMK="\[\033[1;30m\]"
  local EMR="\[\033[1;31m\]"
  local EMG="\[\033[1;32m\]"
  local EMY="\[\033[1;33m\]"
  local EMB="\[\033[1;34m\]"
  local EMM="\[\033[1;35m\]"
  local EMC="\[\033[1;36m\]"
  local EMW="\[\033[1;37m\]"

  # background colors
  local BGK="\[\033[40m\]"
  local BGR="\[\033[41m\]"
  local BGG="\[\033[42m\]"
  local BGY="\[\033[43m\]"
  local BGB="\[\033[44m\]"
  local BGM="\[\033[45m\]"
  local BGC="\[\033[46m\]"
  local BGW="\[\033[47m\]"

  local UC=$W                 # user's color
  [ $UID -eq "0" ] && UC=$R   # root's color
}

ensure_update_terminal_cwd() {
  # echo -ne "\033]0;${PWD##/*/}\007"
  type update_terminal_cwd 2>&1 | grep -q 'shell function'
  if [ $? -ne 0 ]
  then
    local SEARCH=' ';
    local REPLACE='%20';
    local PWD_URL="file://$HOSTNAME${PWD//$SEARCH/$REPLACE}";
    printf '\e]7;%s\a' "$PWD_URL"
  else
    update_terminal_cwd;
  fi
}
export PROMPT_COMMAND='ps1_set;ensure_update_terminal_cwd;'
